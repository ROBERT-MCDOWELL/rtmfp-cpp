// Copyright © 2021 Michael Thornburgh
// SPDX-License-Identifier: MIT

#include <openssl/bn.h>
#include <openssl/evp.h>
#include <openssl/hmac.h>
#include <openssl/rand.h>

#include "../include/rtmfp/FlashCryptoAdapter_OpenSSL.hpp"

namespace com { namespace zenomt { namespace rtmfp {

namespace {

struct MODP_Group {
	int                  group_id;
	const unsigned char *g;
	size_t               g_len;
	const unsigned char *modulus;
	size_t               modulus_len;
	size_t               exponent_len_bits;
};

const uint8_t TWO[] = { 2 };

// RFC 7296 §B.2, also RFC 2409 §6.2
const unsigned char MODP_1024[] = {
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,
	0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1, 0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,
	0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22, 0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,
	0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B, 0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,
	0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45, 0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,
	0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B, 0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,
	0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5, 0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,
	0x49, 0x28, 0x66, 0x51, 0xEC, 0xE6, 0x53, 0x81, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// RFC 3526 §3
const unsigned char MODP_2048[] = {
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,
	0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1, 0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,
	0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22, 0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,
	0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B, 0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,
	0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45, 0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,
	0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B, 0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,
	0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5, 0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,
	0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D, 0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,
	0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A, 0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,
	0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96, 0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,
	0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D, 0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,
	0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x18, 0x21, 0x7C, 0x32, 0x90, 0x5E, 0x46, 0x2E, 0x36, 0xCE, 0x3B,
	0xE3, 0x9E, 0x77, 0x2C, 0x18, 0x0E, 0x86, 0x03, 0x9B, 0x27, 0x83, 0xA2, 0xEC, 0x07, 0xA2, 0x8F,
	0xB5, 0xC5, 0x5D, 0xF0, 0x6F, 0x4C, 0x52, 0xC9, 0xDE, 0x2B, 0xCB, 0xF6, 0x95, 0x58, 0x17, 0x18,
	0x39, 0x95, 0x49, 0x7C, 0xEA, 0x95, 0x6A, 0xE5, 0x15, 0xD2, 0x26, 0x18, 0x98, 0xFA, 0x05, 0x10,
	0x15, 0x72, 0x8E, 0x5A, 0x8A, 0xAC, 0xAA, 0x68, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// RFC 3526 §5
const unsigned char MODP_4096[] = {
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,
	0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1, 0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,
	0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22, 0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,
	0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B, 0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,
	0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45, 0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,
	0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B, 0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,
	0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5, 0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,
	0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D, 0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,
	0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A, 0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,
	0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96, 0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,
	0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D, 0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,
	0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x18, 0x21, 0x7C, 0x32, 0x90, 0x5E, 0x46, 0x2E, 0x36, 0xCE, 0x3B,
	0xE3, 0x9E, 0x77, 0x2C, 0x18, 0x0E, 0x86, 0x03, 0x9B, 0x27, 0x83, 0xA2, 0xEC, 0x07, 0xA2, 0x8F,
	0xB5, 0xC5, 0x5D, 0xF0, 0x6F, 0x4C, 0x52, 0xC9, 0xDE, 0x2B, 0xCB, 0xF6, 0x95, 0x58, 0x17, 0x18,
	0x39, 0x95, 0x49, 0x7C, 0xEA, 0x95, 0x6A, 0xE5, 0x15, 0xD2, 0x26, 0x18, 0x98, 0xFA, 0x05, 0x10,
	0x15, 0x72, 0x8E, 0x5A, 0x8A, 0xAA, 0xC4, 0x2D, 0xAD, 0x33, 0x17, 0x0D, 0x04, 0x50, 0x7A, 0x33,
	0xA8, 0x55, 0x21, 0xAB, 0xDF, 0x1C, 0xBA, 0x64, 0xEC, 0xFB, 0x85, 0x04, 0x58, 0xDB, 0xEF, 0x0A,
	0x8A, 0xEA, 0x71, 0x57, 0x5D, 0x06, 0x0C, 0x7D, 0xB3, 0x97, 0x0F, 0x85, 0xA6, 0xE1, 0xE4, 0xC7,
	0xAB, 0xF5, 0xAE, 0x8C, 0xDB, 0x09, 0x33, 0xD7, 0x1E, 0x8C, 0x94, 0xE0, 0x4A, 0x25, 0x61, 0x9D,
	0xCE, 0xE3, 0xD2, 0x26, 0x1A, 0xD2, 0xEE, 0x6B, 0xF1, 0x2F, 0xFA, 0x06, 0xD9, 0x8A, 0x08, 0x64,
	0xD8, 0x76, 0x02, 0x73, 0x3E, 0xC8, 0x6A, 0x64, 0x52, 0x1F, 0x2B, 0x18, 0x17, 0x7B, 0x20, 0x0C,
	0xBB, 0xE1, 0x17, 0x57, 0x7A, 0x61, 0x5D, 0x6C, 0x77, 0x09, 0x88, 0xC0, 0xBA, 0xD9, 0x46, 0xE2,
	0x08, 0xE2, 0x4F, 0xA0, 0x74, 0xE5, 0xAB, 0x31, 0x43, 0xDB, 0x5B, 0xFC, 0xE0, 0xFD, 0x10, 0x8E,
	0x4B, 0x82, 0xD1, 0x20, 0xA9, 0x21, 0x08, 0x01, 0x1A, 0x72, 0x3C, 0x12, 0xA7, 0x87, 0xE6, 0xD7,
	0x88, 0x71, 0x9A, 0x10, 0xBD, 0xBA, 0x5B, 0x26, 0x99, 0xC3, 0x27, 0x18, 0x6A, 0xF4, 0xE2, 0x3C,
	0x1A, 0x94, 0x68, 0x34, 0xB6, 0x15, 0x0B, 0xDA, 0x25, 0x83, 0xE9, 0xCA, 0x2A, 0xD4, 0x4C, 0xE8,
	0xDB, 0xBB, 0xC2, 0xDB, 0x04, 0xDE, 0x8E, 0xF9, 0x2E, 0x8E, 0xFC, 0x14, 0x1F, 0xBE, 0xCA, 0xA6,
	0x28, 0x7C, 0x59, 0x47, 0x4E, 0x6B, 0xC0, 0x5D, 0x99, 0xB2, 0x96, 0x4F, 0xA0, 0x90, 0xC3, 0xA2,
	0x23, 0x3B, 0xA1, 0x86, 0x51, 0x5B, 0xE7, 0xED, 0x1F, 0x61, 0x29, 0x70, 0xCE, 0xE2, 0xD7, 0xAF,
	0xB8, 0x1B, 0xDD, 0x76, 0x21, 0x70, 0x48, 0x1C, 0xD0, 0x06, 0x91, 0x27, 0xD5, 0xB0, 0x5A, 0xA9,
	0x93, 0xB4, 0xEA, 0x98, 0x8D, 0x8F, 0xDD, 0xC1, 0x86, 0xFF, 0xB7, 0xDC, 0x90, 0xA6, 0xC0, 0x8F,
	0x4D, 0xF4, 0x35, 0xC9, 0x34, 0x06, 0x31, 0x99, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

MODP_Group modp_groups[] = {
	{ 16, TWO, sizeof(TWO), MODP_4096, sizeof(MODP_4096), 480 }, // RFC 3526 §5, §8
	{ 14, TWO, sizeof(TWO), MODP_2048, sizeof(MODP_2048), 320 }, // RFC 3526 §3, §8
	{ 2, TWO, sizeof(TWO), MODP_1024, sizeof(MODP_1024), 224 }, // RFC 7296 §B.2, §5
	{ -1, NULL, 0, NULL, 0, 0 }
};

const MODP_Group * findGroupParams(int groupID)
{
	for(int i = 0; modp_groups[i].group_id >= 0; i++)
		if(groupID == modp_groups[i].group_id)
			return &modp_groups[i];
	return nullptr;
}

class HMACSHA256_Context_OpenSSL : public HMACSHA256_Context {
public:
	HMACSHA256_Context_OpenSSL() : m_ctx(nullptr), m_keyLen(0), m_dirty(false)
	{ }

	~HMACSHA256_Context_OpenSSL()
	{
		if(m_ctx)
			HMAC_CTX_free(m_ctx);
		m_ctx = nullptr;
	}

	bool init(const void *key, size_t len) override
	{
		if(m_ctx)
			return false;

		m_ctx = HMAC_CTX_new();
		if((not m_ctx) or (not HMAC_Init_ex(m_ctx, key, (int)len, EVP_sha256(), NULL)))
			return false;

		m_keyLen = len;

		return true;
	}

	bool compute(void *md, const void *msg, size_t len) override
	{
		if(m_dirty and not HMAC_Init_ex(m_ctx, NULL, m_keyLen, NULL, NULL))
			return false;

		m_dirty = true;

		if( (not HMAC_Update(m_ctx, (const unsigned char *)msg, (int)len))
		 or (not HMAC_Final(m_ctx, (unsigned char *)md, NULL))
		)
			return false;

		return true;
	}

protected:
	HMAC_CTX *m_ctx;
	size_t    m_keyLen;
	bool      m_dirty;
};

class AES_Context_OpenSSL : public AES_Context {
public:
	AES_Context_OpenSSL() : m_ctx(nullptr)
	{ }

	~AES_Context_OpenSSL()
	{
		if(m_ctx)
			EVP_CIPHER_CTX_free(m_ctx);
		m_ctx = nullptr;
	}

	bool init(const void *key, size_t len, bool encrypt) override
	{
		if(m_ctx or 16 != len)
			return false;

		m_ctx = EVP_CIPHER_CTX_new();
		if(not m_ctx)
			return false;

		if( (not EVP_CipherInit_ex(m_ctx, EVP_aes_128_cbc(), NULL, (const unsigned char *)key, NULL, encrypt ? 1 : 0))
		 or (not EVP_CIPHER_CTX_set_padding(m_ctx, 0))
		)
			return false;

		return true;
	}

	bool crypt_cbc(const void *dst, const void *src, size_t len, uint8_t *iv) override
	{
		int outl = len;

		if( (not EVP_CipherInit_ex(m_ctx, NULL, NULL, NULL, (const unsigned char *) iv, -1))
		 or (not EVP_CipherUpdate(m_ctx, (unsigned char *)dst, &outl, (const unsigned char *)src, len))
		)
			return false;

		if(outl != (int)len)
			return false;

		return true;
	}

protected:
	EVP_CIPHER_CTX *m_ctx;
};

class DH_Context_OpenSSL : public DH_Context {
public:
	DH_Context_OpenSSL() :
		m_exponent(nullptr),
		m_g(nullptr),
		m_modulus(nullptr)
	{
	}

	~DH_Context_OpenSSL()
	{
		if(m_exponent)
			BN_clear_free(m_exponent);
		m_exponent = nullptr;
		if(m_g)
			BN_clear_free(m_g);
		m_g = nullptr;
		if(m_modulus)
			BN_clear_free(m_modulus);
		m_modulus = nullptr;
	}

	bool init(int groupID) override
	{
		if(m_exponent)
			return false;

		const MODP_Group *groupParams = findGroupParams(groupID);
		if(not groupParams)
			return false;

		m_exponent = BN_secure_new();
		if( (not m_exponent)
		 or (not BN_rand(m_exponent, groupParams->exponent_len_bits, BN_RAND_TOP_ONE, BN_RAND_BOTTOM_ANY))
		)
			return false;

		if( (not (m_g = BN_bin2bn(groupParams->g, groupParams->g_len, NULL)))
		 or (not (m_modulus = BN_bin2bn(groupParams->modulus, groupParams->modulus_len, NULL)))
		 or (not modp(m_g, m_public))
		)
			return false;

		return true;
	}

	Bytes getPublicKey() const override
	{
		return m_public;
	}

	bool computeSharedSecret(const void *otherPublic, size_t len, Bytes &dst) const override
	{
		if(not m_exponent)
			return false;

		BIGNUM *otherBN = BN_bin2bn((const unsigned char *)otherPublic, len, NULL);
		bool rv = otherBN and validate_public(otherBN, otherPublic, len) and modp(otherBN, dst);

		if(otherBN)
			BN_free(otherBN);

		return rv;
	}

protected:
	// implement §4.6.2 checks on the public key
	bool validate_public(BIGNUM *p, const void *pBytes_, size_t pLen) const
	{
		const uint8_t *pBytes = (const uint8_t *)pBytes_;
		bool rv = true;
		unsigned char TWO_TO_24TH[] = { 1, 0, 0, 0 };
		BIGNUM *two_to_24th_bn = BN_bin2bn(TWO_TO_24TH, sizeof(TWO_TO_24TH), NULL);
		BIGNUM *cutoff = BN_new();

		if((not cutoff) or (not two_to_24th_bn) or not BN_sub(cutoff, m_modulus, two_to_24th_bn))
		{
			// BN_sub should not fail, but we're always supposed to check
			BN_free(cutoff);
			BN_free(two_to_24th_bn);
			return false;
		}

		if(BN_cmp(p, two_to_24th_bn) < 0)
			rv = false; // must be at least 2^24
		if(BN_cmp(p, cutoff) > 0)
			rv = false; // must be at most modulus minus 2^24

		size_t num0 = 0;
		size_t num1 = 0;
		bool leading = true;
		for(size_t i = 0; i < pLen; i++)
		{
			uint8_t b = pBytes[i];

			if(leading and not b)
				continue;
			leading = false;

			if(0 == b)
				num0 += 8;
			else if(0xff == b)
				num1 += 8;
			else
			{
				for(int bit = 0; bit < 8; bit++)
				{
					if(b & 1)
						num1++;
					else
						num0++;
					b >>= 1;
				}
			}
		}

		if(num0 < 16)
			rv = false;
		if(num1 < 16)
			rv = false;

		BN_free(cutoff);
		BN_free(two_to_24th_bn);
		return rv;
	}

	bool modp(BIGNUM *b, Bytes &dst) const
	{
		bool rv = false;
		int resultLen;
		BIGNUM *result = BN_secure_new();
		BN_CTX *ctx = BN_CTX_secure_new();

		if((not result) or (not ctx) or not BN_mod_exp(result, b, m_exponent, m_modulus, ctx))
			goto finish;

		resultLen = BN_num_bytes(result);
		dst.resize(resultLen);
		BN_bn2bin(result, (unsigned char *)dst.data());

		rv = true;

	finish:
		if(result)
			BN_clear_free(result);
		if(ctx)
			BN_CTX_free(ctx);

		return rv;
	}

	Bytes   m_public;
	BIGNUM *m_exponent;
	BIGNUM *m_g;
	BIGNUM *m_modulus;
};

}

// --- FlashCryptoAdapter_OpenSSL

void FlashCryptoAdapter_OpenSSL::pseudoRandomBytes(uint8_t *dst, size_t len)
{
	RAND_bytes(dst, (int)len);
}

std::vector<int> FlashCryptoAdapter_OpenSSL::getSupportedDHGroups() const
{
	std::vector<int> rv;
	for(int i = 0; modp_groups[i].group_id >= 0; i++)
		rv.push_back(modp_groups[i].group_id);
	return rv;
}

void FlashCryptoAdapter_OpenSSL::sha256(void *dst, const void *msg, size_t len) const
{
	EVP_MD_CTX *ctx = EVP_MD_CTX_new();
	EVP_DigestInit_ex(ctx, EVP_sha256(), NULL);
	EVP_DigestUpdate(ctx, msg, len);
	EVP_DigestFinal_ex(ctx, (unsigned char *)dst, NULL);
	EVP_MD_CTX_free(ctx);
}

std::shared_ptr<HMACSHA256_Context> FlashCryptoAdapter_OpenSSL::makeHMAC_Context()
{
	return share_ref(new HMACSHA256_Context_OpenSSL(), false);
}

std::shared_ptr<AES_Context> FlashCryptoAdapter_OpenSSL::makeAES_Context()
{
	return share_ref(new AES_Context_OpenSSL(), false);
}

std::shared_ptr<DH_Context> FlashCryptoAdapter_OpenSSL::makeDH_Context()
{
	return share_ref(new DH_Context_OpenSSL(), false);
}


} } } // namespace com::zenomt::rtmfp
